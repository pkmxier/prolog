# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Лобов В.И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|  16.10.17    |      4--      |

> * Отсутствует предикат обработки списка, используя стандартные предикаты. В отчете отсутствует текст предиката Задания 2 и примеры использования. Отсутствует пример совместного использования предикатов в Задании 1 (п.6 в тексте задания)*


## Введение

Список в Прологе является рекурсивной структурой, представленной в виде набора значений. Внутри списки устроены так же, как в других языках программирования - на основе узлов и указателей. Явно работать с указателями в списках в Прологе нет необходимости. Список задается элементом - головой и хвостом - остальным списком. Список, который не содержит в себе элементов - пустой список([]). Список более приемлим для Пролога ввиду древовидной структуры доказательства истинности формул, т.к. список является частным случаем дерева. В отличие от массивов, принятых в императивных языках программирования, список не имеет доступа к произвольному элементу со сложностью O(1), а только O(N). Но расположение данных в виде списков более эффективно с точки зрения организации в памяти - элементы могут быть разбросаны в разных её местах.

## Задание 1.1: Предикат обработки списка

`remove_n(N, L, T)` - удаляет N элемент списка L (голова имеет индекс 1).

Примеры использования:
```prolog
?- remove_n(1, [a, b, c], X).
X=[2, 3].
X=[b,c].???
?- mypred(N, [1, 2, 3], [1, 2]).
N=3.
```

Реализация:
```prolog
remove_n(1, [X|T], T):-!.
remove_n(N, [X|T], [X|T1]):- N1 is N-1, remove_n(N1, T, T1).
```

Предикат работает рекурсивно. С каждой итерацией генерируется список, на 1 элемент меньший, чем предыдущий. В случае, когда переменная N достигнет значения 1, то голова текущего списка удаляется. При рекурсивном подъеме обратно получается итоговый список.


## Задание 1.2: Предикат обработки числового списка


`sum_vectors(X, Y, Z)` - складывает два числовых вектора-списка X и Y в вектор-список Z.

Примеры использования:

```prolog
?- sum_vectors([1, 2, 3]), [4, 5, 6], X).
X=[5, 7, 9].
```
Реализация:
```prolog
sum_vectors([], X, X).
sum_vectors(X, [], X).
sum_vectors([X|S], [Y|T], [Z|L]):- Z is X+Y, sum_vectors(S, T, L), !.
```

Предикат работает рекурсивно. Головы двух списков складываются, результат сложения - голова итогового списка. Затем, предикат запусакется рекурсивно для хвостов двух списков. Если хотя бы один список стал пустым, то результатом является второй список. При подъеме вверх по рекурсии составляется итоговый список.

## Задание 2: Реляционное представление данных

Достоинство реляционного представления данных студентов, которое я использовал, в том, что доступ к информации о группе и списку оценок за все предметы не представляет особых затруднений, то есть может быть осуществлен за O(1). В то же время поиск оценок в данном списке со стороны сдаваемого предмета, а не студента, вызывает ряд затруднений - приходится проходить весь список целиком.

`student_passed(X)` - предикат истинен, если студент сдал все экзамены(нет ни одной 'двойки'), и ложен, если студент не сдал хотя бы один экзамен.
Рекурсивно просматривается список оценок студента по всем предметам. Если за экзамен оценка 2, то предикат ложен, иначе истинен.

`average_mark(G, X, Y)` - G - группа студента(можно опустить(_)), X - фамилия студента, Y - средняя оценка студента по всем предметам.

Рекурсивно просматриваются оценки студента по всем предметам, они суммируются, а потом полученное число делится на количество предметов(6).

`sub_did_not_passed(X, Y)` - Y - количество студентов, не сдавших предмет X(получивших оценку 2).
Создается список, содержащий списки из оценок всех студентов по всем предметам. Рекурсивно проверяется, содержится ли в голове списка предмет, по которому получена оценка 2 - если содержится, то Y увеличивается на 1, если нет, то просматривается хвост "общего" списка.

`max_mark_students(G, L)` - в группе G ищутся студенты, имеющие максимальный средний балл в ней. L - список фамилий этих студентов.
Ищется максимальный средний балл в данной группе, после чего ищутся студенты этой группы, имеющие такой средний балл.

## Выводы

Данная лабораторная работа была для меня первой возможностью написания программ на Прологе. По мере работы с ней я познакомился со списками и некоторыми встроенными методами работы с ними(findall, bagof, setof...). Минималистичность написания кода на Прологе напомнила мне язык высокого уровня Python. Также я выделил для себя некоторые методы, с помощью которых логику написания программ на Прологе можно сравнить с языками, которые мне довелось изучать на первом курсе, как C и C++. Можно сделать вывод, что Пролог хорошо подходит для метода построения программ от малого к большому. Так, предикаты, реализованные мной в данной лабораторной работе, могут пригодиться для работы со списками во многих других прикладных задачах.

#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Лобов В.И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Для решения задач, представление которых можно описать набором некоторых состояний объектов, можно применять различные алгоритмы поиска в графах. Так, граф можно легко получить, если определить состояния, как его вершины, а дуги, как переходы из одного состояния в другое. Так как любой алгоритм поиска представляет из себя нахождение пути из одной вершины в другую, то в рамках задачи этот путь является ответом на то, какими переходами из одних состояний в другие можно достичь конечного состояния. Таким способом можно легко решать задачи на перемещения объектов из одного места в другое: пятнашки, задача о волке, козе и капусте, задача о коммивояжёре(хоть и не очень эффективно).
Благодаря тому, что поиск решения на Prolog'е основан на обходе дерева, подобные задачи легко решаются использованием алгоритмов поиска. Если при поиске была достигнута вершина(состояние), из которого дальше пути нет, то необходимо откатиться до какого-то предыдущего состояния, которое определяется алгоритмом. Такой процесс backtracing'а заложен "внутри" Prolog'а, поэтому нет необходимости писать в программе дополнительный код. Именно поэтому Prolog является отличным средством для решения подобных задач.
Почему Prolog оказывается удобным языком для решения таких задач?

## Задание
Железнодорожный сортировочный узел устроен так, как показано на рисунке. На левой стороне собрано некоторое число вагонов двух типов(черные и белые), обоих типов по n штук, в произвольном порядке. Тупик вмещает все 2n вагонов. Пользуясь тремя сортировочными операциями (слева в тупик, из тупика направо, слева направо, минуя тупик), собрать вагоны на левой стороне(тут, вероятно, опечатка, необходимо собрать вагоны справа, т.к. нет сортировочной операции движения налево), так, чтобы типы чередовались. Для решения задачи достаточно 3n-1 сортировочных операций.

## Принцип решения

Для решения данной задачи можно использовать такие алгоритмы поиска, как: поиск в глубину, ширину и с итерационным заглублением.
Предикат solve представляет из себя обёртку для поиска данными тремя алгоритмами. В переменных Res1, Res2 и Res3 будут содержаться списки из состояний, пройденных при поиске решения. Для того, чтобы в дальнейшем можно было получать голову списка за O(1), реверсируем исходный список из поездов. Если этого не сделать, то нужно каждый раз удалять последний элемент из списка, что увеличивает сложность до линейной. Это нехорошо. После поиска в переменных R1, R2 и R3 будут находиться реверсированные списки из реверсированных списков. Большой список будет реверсирован также из-за добавления нового элемента при поиске пути в начало. Реверсируем внутренние списки, а затем и внешние, после чего получаем необходимый ответ. С помощью комбинации предикатов permutation и bw мы генерируем перестановку из текущего списка поездов, в которой они чередуются.
```prolog
solve(X, Res1, Res2, Res3):- reverse(X, X1), permutation(X1, Y), bw(Y), dfs(s(X1, [], []), s([], [], Y), R1),
                                                                        bfs(s(X1, [], []), s([], [], Y), R2),
                                                                        id(s(X1, [], []), s([], [], Y), R3),
                                                                        reverse_all(R1, Z1), reverse(Z1, Res1),
                                                                        reverse_all(R2, Z2), reverse(Z2, Res2),
                                                                        reverse_all(R3, Z3), reverse(Z3, Res3), !.
reverse_all([], []).
reverse_all([s(X, Y, Z) | T], [s(P, Q, R) | RT]):- reverse(X, P), reverse(Y, Q), reverse(Z, R), reverse_all(T, RT).

bw(X):- bw1(X); bw2(X).
bw1([]).
%if X is black, then next train must be white
bw1([X | T]):- X==b, bw2(T).
bw2([]).
%if X is white, then next train must be black
bw2([X | T]):- X==w, bw1(T).
```

В каждом алгоритме поиска необходимо продлевать текущий путь в следующую вершину. С этим справляется предикат prolong. Если возможно переместиться из состояния X в состояние Y, и Y не содержится в текущем списке пути(чтобы не было зацикливания), то идём в эту вершину.
```prolog
prolong([X | T], [Y, X | T]):- move(X, Y), \+(member(Y, [X | T])).
```

Поиск в глубину весьма прост - если было достигнуто необходимое состояние, то предикат поиска завершает работу. Если нет, то продлеваем текущий путь и ищем по нему дальше.
```prolog
dfs_path([X | T], X, [X | T]).
dfs_path(P, B, R):- prolong(P, P1), dfs_path(P1, B, R).
dfs(A, B, R):- dfs_path([A], B, R).
```

Поиск в ширину чуть-чуть сложнее - происходит поиск всемозможных продлеваний пути из данной вершины, и они добавляются в один список. Затем поиск продолжается из каждой вершины в данном списке тем же самым способом.
```prolog
path([[X | T] | _], X, [X | T]).
path([P | Q], B, R):- findall(X, prolong(P, X), L), append(Q, L, QL), !, path(QL, B, R).
path([_ | Q], B, R):- path(Q, B, R).
bfs(A, B, R):- path([[A]], B, R).
```

Поиск с итерационным заглублением отличается от поиска в глубину лишь тем, что в ответ попадают только те пути, длина которых меньше числа N. В данной задаче количество передвижений поездов должно быть ограничено 3*N-1, где N - количество поездов одного цвета, поэтому целесообразно выбрать данную величину таковой.
```prolog
id_path([X | T], X, [X | T], _).
id_path(P, B, R, N):- N > 0, prolong(P, P1), N1 is N - 1, id_path(P1, B, R, N1).
id(s(X, Y, Z), B, R):- length(X, L), N is 3 * L / 2, id_path([s(X, Y, Z)], B, R, N).
```

Передвижения поездов для каждого алгоритма одни и те же: если справа поезд, отличный от поезда слева, то нужно перевезти один поезд туда либо слева, либо снизу; если же эти случаи невозможны, то передвигаем поезд слева вниз.
```prolog
move(s([A | AT], B, C), s(AT, B, [A | C])):- first(C, X), X \= A.
move(s(A, [B | BT], C), s(A, BT, [B | C])):- first(C, X), X \= B.
move(s([A | AT], B, C), s(AT, [A | B], C)):- first(C, X), X == A.
```
## Результаты

Так как в данной задаче граф из состояний содержит всего 3 вершины и 3 дуги, то работа алгоритмов почти идентична. Если бы не существовало условий для передвижений поезда, то есть они двигались как хотели, то поиск выполнялся бы за большее время. С целью уменьшить время поиска эти условия и были добавлены.

## Выводы

Для решения данной задачи нет разницы, какой из алгоритмов поиска использовать. Но, так как в условии сказано, что достаточно 3*n-1 перестановок поездов, то было бы разумно использовать поиск с итерационным заглублением. Таким образом, всевозможные пути длиннее данной величины будут точно отсечены и не попадут в ответ. Но, как я уже сказал, это излишне, так как 3 условия перехода обеспечивают нужный результат.

Данная лабораторная работа помогла мне лучше понять принцип работы данных алгоритмов поиска в графе, так как их реализация на Prolog'е наглядно это демонстрирует. Подобные алгоритмы я могу использовать и дальше, в том числе и в моей курсовой работе, где вершинами графа являются мои родственники из родословного дерева, а связями их родственные отношения. Это существенно облегчает задачу поиска отношения двух различных людей в нём.

#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Лобов В.И.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Будучи логическим языком, Prolog, очевидно, является отличным средством для поиска решения логических задач. Факты, соответствующие условию задачи, могут быть легко записаны в виде утверждений логики предикатов. После этого написать программу, которая будет искать решение данной задачи, не составит труда(в силу её предикатного описания). Существует несколько общих техник для составления программ решения различных задач. Наиболее широкой является перебор всех вариантов с последующим отсеиванием неподходящих. Для того, чтобы выбрать только те факты, которые справедливы по условию задачи, необходимо их перечислить каким-либо образом. Это можно сделать в виде отдельных предикатов, каждый из которых отвечает за один факт, с помощью предиката member или sublist, чтобы выполнялось условие принадлежности некоторому множеству. Если какой-либо факт ложен, то имеет смысл разделить все факты на справедливые и нет, при этом нужно рассмотреть оба варианта с помощью предиката logicalnot(X, Y), который меняет true на false и наоборот. Задача поиска решения для всевозможных задач одним универсальным алгоритмом алгоритмически не выполнима, т.к. не существует(пока) алгоритма, который мог бы решить любую задачу. Для каждой существуют некоторые особенности, в чем я убедился на собственном опыте. 

## Задание
Вариант №10.
В одном городе живут 5 человек. Их имена Леонид, Михаил, Николай, Олег и Петр. Их фамилии Атаров, Бартенев, Кленов, Данилин и Иванов. Бартенев знаком только с двумя из перечисленных мужчин. Петр знаком со всеми, кроме одного. Леонид знаком только с одним из всех. Данилин и Михаил незнакомы. Николай и Иванов знают друг друга. Михаил, Николай и Олег знакомы между собой. Атаров незнаком только с одним из всех. Только один из всех знаком с Кленовым. Назовите имена и фамилии каждого. С кем знаком каждый из них?

## Принцип решения

В основе решения лежит почти полный перебор всевозможных вариантов фамилий каждого человека и различных списков людей, которых он знает.
Для того, чтобы проверить, знает ли человек с каким-либо именем(не фамилией) другого человека, достаточно использовать предикат member, т.к. информация об этом человеке находится в списке:
```prolog
member([_, nickolay], MichaelFriends). %Проверка, есть ли Николай в списке знакомых Михаила
или
member([danilin, _], OlegFriends). %Проверка, есть ли Данилин в списке знакомых Олега
```

В случае, если нужно понять, знает ли человек с какой-либо фамилией другого человека, необходимо использовать предикат surnameFriends:
```prolog
surnameFriends(S, [S | _], [SF | _], SF).                               %S - фамилия человека. Если такая фамилия унифицирована с фамилией из общего списка фамилий, то 
surnameFriends(X, [_ | Y], [_ | Z], SF):- surnameFriends(X , Y, Z, SF). %соответствующий список знакомых SF принадлежит этому человеку.
```

Так как использование предиката not("\+") для предиката, содержащего еще не унифицированные переменные, приведёт не к тем результатам, которого мы хотели добиться(решить задачу), то перед его использованием необходимо инициализировать списки знакомых каждого человека каким-либо образом. Это порождает полный перебор всевозможных вариантов, т.к. для каждого человека теоретически может быть от 0 до 5 знакомых. Для этого я использовал предикат initFriends:
```prolog
initFriends([], _).                                         %Если все списки уже проинициализированы, то выходим из рекурсии
initFriends([X | T], L):- sublist(X, L), initFriends(T, L). %Генерируем для списка X набор людей, которых человек, привязанный к этому списку, знает, дальше генерируем для всех оставшихся
```

В случае, если первый человек знает второго, то второй также должен знать первого, иначе получается довольно абсурдная ситуация. Если человек с именем знает другого с именем, то достаточно предиката member, чтобы это описать. Если же известно только количество людей, которых знает данный человек, то необходимо для каждого друга описать то, что он знает этого человека. В данной задаче я описал такое правило только для Леонида.
```prolog
%Если Михаил знает Леонида, то все остальные не знают, если Николай знает и т.д...
(member([Leonid, leonid], MichaelFriends),
    (\+(member([Leonid, leonid], NickolayFriends)), \+(member([Leonid, leonid], OlegFriends)), \+(member([Leonid, leonid], PeterFriends)));
    
member([Leonid, leonid], NickolayFriends),
    (\+(member([Leonid, leonid], MichaelFriends)), \+(member([Leonid, leonid], OlegFriends)), \+(member([Leonid, leonid], PeterFriends)));
    
member([Leonid, leonid], OlegFriends),
    (\+(member([Leonid, leonid], MichaelFriends)), \+(member([Leonid, leonid], NickolayFriends)), \+(member([Leonid, leonid], PeterFriends)));
    
member([Leonid, leonid], PeterFriends),
    (\+(member([Leonid, leonid], MichaelFriends)), \+(member([Leonid, leonid], NickolayFriends)), \+(member([Leonid, leonid], OlegFriends)))),
```
Я сделал это потому, что в случае, если описать всевозможные двусторонние связи для каждого человека, получится Очень большой перебор всех возможных вариантов. С учётом того, что программа на моём компьютере работает около 7 минут, я на протяжении часа не смог дождаться какого-либо результата, поэтому для Бартенёва и Атарова, у которых 2 и 3 знакомых соответственно, я такой вариант не описал. Это порождает не единственное решение, но сделано это лишь для того, чтобы программа все-таки закончила работу. Первый результат, который в дереве решений лежит самым левым, является правильным. Для того, чтобы дальнейший перебор не продалжался, необходимо отсечение.

## Выводы

Данная лабораторная работа заняла у меня достаточно большое количество времени. В первую очередь это связано с тем, что хотелось написать более производительную программу, в которой отсутствует полный перебор. Этого сделать не удалось, но, тем не менее, я более глубоко осознал особенности написания программ на Prolog'е. Эта лабораторная работа научила меня мыслить не в глубину, а в ширину, чтобы еще на начальной стадии разработки программы можно было выделить несколько различных путей её развития. Такой подход позволяет выделить из них наиболее производительный/легко пишущийся/просто читающийся, такой, который подходит в данных условиях лучше остальных. Кроме того, я серьезно задумался над проблемой эффективности программ в языке Prolog. Что, если существует другой язык, позволяющий более эффективно решать подобные логические задачи? Может быть Mercury, Visual Prolog или Oz могут обеспечить другой функционал, который сочетает в себе эффективность с простотой написания кода? Для этого необходима дальнейшая практика в данной области.




